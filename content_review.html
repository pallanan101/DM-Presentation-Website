<div id="content-review-container" class="space-y-6">
    
    <div id="content-review" class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-10">
        </div>

    <div id="pending-moderation-list-page" class="page-content space-y-6 hidden">
        <h2 id="queue-title" class="text-2xl font-bold text-gray-900">Queue Tasks</h2>
        <div id="history-control-bar" class="flex justify-between items-center mb-4">
            <div class="flex items-center space-x-4">
                <div class="relative w-full max-w-sm">
                    <input
                        type="text"
                        id="history-search-input"
                        placeholder="Search Content ID, Content, or Assigned To"
                        class="search-input w-full p-2 pl-10 rounded-lg bg-gray-200 text-gray-900 focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
                    />
                    <i class="fas fa-search absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 text-sm"></i>
                </div>

                <div class="flex items-center space-x-2">
                    <input type="date" id="history-start-date" class="p-2 rounded-lg bg-gray-200 text-gray-900 text-sm" />
                    <span class="text-gray-500">to</span>
                    <input type="date" id="history-end-date" class="p-2 rounded-lg bg-gray-200 text-gray-900 text-sm" />
                    <button id="history-apply-filter-button" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm">Apply</button>
                </div>
            </div>

            <button onclick="backToQueueList()" class="bg-gray-200 hover:bg-gray-400 text-gray-900 px-4 py-2 rounded-lg text-sm transition duration-150">‚Üê Back to Queues</button>
        </div>

        <div class="full-width-flex">
            <div class="list-container">
                <div class="pending-list-row font-semibold bg-gray-200 text-gray-900">
                    <div class="text-left"><button class="sortable-header" data-sort-key="task_id">Content ID<i class="fas fa-sort ml-1"></i></button></div>
                    <div class="text-left"><button class="sortable-header" data-sort-key="content">Content<i class="fas fa-sort ml-1"></i></button></div>
                    <div class="text-left"><button class="sortable-header" data-sort-key="source">Source<i class="fas fa-sort ml-1"></i></button></div>
                    <div class="text-left"><button class="sortable-header" data-sort-key="created_at">Entry Date<i class="fas fa-sort ml-1"></i></button></div>
                    <div class="text-left"><button class="sortable-header" data-sort-key="status">Status<i class="fas fa-sort ml-1"></i></button></div>
                    <div class="text-left"><button class="sortable-header" data-sort-key="violation">Violation<i class="fas fa-sort ml-1"></i></button></div>
                    <div class="text-left"><button class="sortable-header" data-sort-key="assigned_to">Assigned To<i class="fas fa-sort ml-1"></i></button></div>
                    <div class="text-left">Action</div>
                </div>
                <div id="pending-list-container"></div>
            </div>
        </div>
    </div>
</div>

<div id="media-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 items-center justify-center hidden" onclick="closeMediaModal(event)">
    <div class="bg-white p-6 rounded-lg shadow-xl max-w-4xl w-full mx-4 relative" onclick="event.stopPropagation()">
        <button onclick="closeMediaModal()" class="absolute top-2 right-2 text-gray-700 hover:text-red-500 text-3xl font-bold z-50 leading-none h-8 w-8">&times;</button>
        <div id="modal-content-area" class="w-full h-full flex justify-center items-center">
            </div>
    </div>
</div>


<script>
    // Global variable assumed to be available from the main app's login script
    let currentUsername = localStorage.getItem('currentUsername') || 'Jon'; 
    
    // Violation mapping (Extracted from script in app3.3.html)
    const violationOptions = {
      1: 'Spam',
      2: 'Harassment',
      3: 'Hate Speech',
      4: 'Misinformation',
      5: 'Offensive Content'
    };
    
    // Task management state
    const lockedTasks = new Set();
    let currentQueueType = null;
    let pendingSortKey = 'task_id';
    let pendingSortDirection = 'asc';
    let socket; // WebSocket object

    // --- VIEW SWITCHING FUNCTIONS ---
    function showModerationTable(queueId, queueName) {
        currentQueueType = queueId;
        document.getElementById('content-review').style.display = 'none';
        document.getElementById('pending-moderation-list-page').classList.remove('hidden');
        document.getElementById('queue-title').textContent = `Tasks for ${queueName}`;
        loadModerationTasks();
    }

    window.backToQueueList = function() { // Added to window object as it's called from inline HTML
        document.getElementById('pending-moderation-list-page').classList.add('hidden');
        document.getElementById('content-review').style.display = 'grid';
        loadContentReviewQueues(); // Optionally reload queues to update counts
    }

    // --- API & DATA LOADING FUNCTIONS ---
    async function loadContentReviewQueues() {
        const container = document.getElementById('content-review');
        container.innerHTML = ''; 

        try {
            const token = localStorage.getItem('authToken');
            const res = await fetch('http://124.107.124.196:3000/api/queues', {
                headers: { Authorization: `Bearer ${token}` }
            });

            const result = await res.json();
            const queues = result.queues;
            
            queues.forEach(queue => {
                const card = document.createElement('div');
                // The card needs the dark-card class defined in the main app's CSS
                card.classList.add('dark-card', 'nav-card', 'p-6', 'cursor-pointer'); 
                card.dataset.queueType = queue.queue_name;

                card.innerHTML = `
                    <h3 class="text-xl font-semibold mb-2 text-gray-900">${queue.queue_name}</h3>
                    <p class="text-gray-500 mb-2">Pending tasks in this queue</p>
                    <div class="flex justify-between items-center text-sm text-gray-500">
                      <span>Tasks: <span class="font-medium text-gray-900">${queue.pending_count}</span></span>
                      <span>Queue ID: ${queue.queue_id}</span>
                    </div>
                `;
                
                // Add click listener to show the task table
                card.addEventListener('click', () => {
                    showModerationTable(queue.queue_id, queue.queue_name);
                });
                
                container.appendChild(card);
            });
        } catch (err) {
            console.error('Failed to load queues:', err);
            container.innerHTML = '<div class="text-red-500">Error loading moderation queues</div>';
        }
    }

    async function loadModerationTasks() {
        const container = document.getElementById('pending-list-container');
        const searchTerm = document.getElementById('history-search-input').value.toLowerCase();
        const startDate = document.getElementById('history-start-date').value;
        const endDate = document.getElementById('history-end-date').value;
        const PLACEHOLDER_IMAGE_URL = 'https://i.pinimg.com/originals/19/51/dc/1951dc32a49c80597fa73876a70e9e1b.jpg';

        try {
            const token = localStorage.getItem('authToken');
            const res = await fetch(`http://124.107.124.196:3000/api/queues/${currentQueueType}/tasks`, {
                headers: { Authorization: `Bearer ${token}` }
            });
            let result = await res.json();
            let tasks = Array.isArray(result) ? result : result.tasks || [];

            // Filtering and Sorting (Logic kept from app3.3.html)
            if (startDate && endDate) {
                const start = new Date(startDate);
                const end = new Date(endDate);
                tasks = tasks.filter(task => {
                    const taskDate = new Date(task.created_at);
                    const inclusiveEnd = new Date(end);
                    inclusiveEnd.setDate(inclusiveEnd.getDate() + 1); 
                    return taskDate >= start && taskDate < inclusiveEnd;
                });
            }
            if (searchTerm) {
                tasks = tasks.filter(task =>
                    task.task_id?.toString().toLowerCase().includes(searchTerm) ||
                    task.content?.toLowerCase().includes(searchTerm) ||
                    task.assigned_to?.toLowerCase().includes(searchTerm)
                );
            }
            tasks.sort((a, b) => {
                const aVal = (a[pendingSortKey] || '').toString().toLowerCase();
                const bVal = (b[pendingSortKey] || '').toString().toLowerCase();
                return pendingSortDirection === 'asc'
                    ? aVal.localeCompare(bVal)
                    : bVal.localeCompare(aVal);
            });

            // Render
            container.innerHTML = '';
            const queueId = currentQueueType; // Use the current queue ID for content type logic

            tasks.forEach(task => {
                const row = document.createElement('div');
                row.classList.add('pending-list-row');
                // Hardcoded styles for dynamic rows (Note: Custom CSS should handle dark/light mode for .pending-list-row)
                row.style.gridTemplateColumns = '100px 400px 100px 120px 80px 150px 150px 300px'; 
                row.style.display = 'grid';
                row.dataset.taskId = task.task_id;

                const content = task.content || '';
                const assignedUser = task.assigned_to || 'Unassigned'; 

                let contentCellInnerHtml = `<span class="text-gray-800 text-sm truncate">${([1, 2, 3, 6, 7].includes(queueId)) ? content : ''}</span>`;
                
                const baseRowContent = `
                    <div style="display:flex;align-items:center;" class="text-gray-800 text-xs">${task.task_id}</div>
                    <div style="display:flex;align-items:center;" class="text-gray-800 text-sm truncate content-cell">${contentCellInnerHtml}</div>
                    <div style="display:flex;align-items:center;" class="text-gray-500 text-sm">${task.source}</div>
                    <div style="display:flex;align-items:center;" class="text-gray-500 text-xs">${task.created_at}</div>
                    <div style="display:flex;align-items:center;" class="text-gray-800 text-sm">${task.status}</div>
                    <select id="violation-${task.task_id}" class="text-sm px-2 py-1 rounded border border-gray-300 bg-white text-gray-700">
                        <option disabled value="0" ${!task.violation_id ? 'selected' : ''}>Select violation</option>
                        ${Object.entries(violationOptions).map(([val, label]) =>
                            `<option value="${val}" ${parseInt(val) === task.violation_id ? 'selected' : ''}>${label}</option>`).join('')}
                    </select>
                    <div style="display:flex;align-items:center;" class="text-gray-500 text-sm assigned-to-cell">${assignedUser}</div> 
                    <div style="display:flex;align-items:center;" class="action-cell">
                        <button id="claimbutton-${task.task_id}" onclick="claimTask(${task.task_id})" class="bg-blue-600 hover:bg-blue-700 text-white text-xs px-3 py-1 rounded-full">Claim</button>
                        <button id="approve-${task.task_id}" onclick="resolveTask(${task.task_id}, 'Approved')" class="bg-gray-400 text-white text-xs px-3 py-1 rounded-full ml-2" disabled>Approve</button>
                        <button id="reject-${task.task_id}" onclick="resolveTask(${task.task_id}, 'Rejected')" class="bg-gray-400 text-white text-xs px-3 py-1 rounded-full ml-2" disabled>Reject</button>
                    </div>
                `;

                // Handle Media Content
                if ([8, 9].includes(queueId)) { // Video Logic
                    const embedUrl = content.includes('youtube.com') 
                        ? content.split('v=')[1]?.split('&')[0]
                        : content.match(/(youtu\.be\/|v=)([^&]+)/i)?.[2];
                    
                    const mediaElement = `
                        <img 
                            src="${PLACEHOLDER_IMAGE_URL}" 
                            alt="Video Placeholder" 
                            class="cursor-pointer" 
                            style="width:100px;height:100px;object-fit:cover;border-radius:6px; border: 2px solid #ef4444;" 
                            onclick="event.stopPropagation(); openMediaModal('video', '${embedUrl}')">
                    `;
                    
                    row.innerHTML = baseRowContent.replace(
                        `<div style="display:flex;align-items:center;" class="text-gray-800 text-sm truncate content-cell">${contentCellInnerHtml}</div>`,
                        `<div style="display:flex;align-items:center;" class="content-cell">${mediaElement}</div>`
                    );

                } else if ([4, 5].includes(queueId)) { // Image Logic
                    const isImage = content.match(/\.(jpg|jpeg|png|gif)$/i);
                    const mediaElement = isImage 
                        ? `<img src="${content}" alt="Image" class="cursor-pointer" style="width:100px;height:100px;object-fit:cover;border-radius:6px;" onclick="event.stopPropagation(); openMediaModal('image', '${content}')">` 
                        : `<span class="text-gray-800 text-sm truncate">${content}</span>`;
                    
                    row.innerHTML = baseRowContent.replace(
                        `<div style="display:flex;align-items:center;" class="text-gray-800 text-sm truncate content-cell">${contentCellInnerHtml}</div>`,
                        `<div style="display:flex;align-items:center;" class="content-cell">${mediaElement}</div>`
                    );
                } else {
                     row.innerHTML = baseRowContent;
                }

                container.appendChild(row);

                // Update highlight state for the row
                const isAssigned = assignedUser !== 'Unassigned';
                updateTaskHighlight(task.task_id, isAssigned, assignedUser);
            });

        } catch (err) {
            console.error('Failed to load moderation tasks:', err);
            container.innerHTML = '<div class="text-red-500">Error loading tasks</div>';
        }
        await syncLockedTasks();
    }


    // --- TASK ACTION FUNCTIONS ---
    async function syncLockedTasks() {
        const token = localStorage.getItem('authToken');
        try {
            const res = await fetch('http://124.107.124.196:3000/api/task-locks', {
                headers: { Authorization: `Bearer ${token}` }
            });
            const result = await res.json();
            if (result.success) {
                result.locks.forEach(lock => {
                    updateTaskHighlight(lock.task_id, true, lock.locked_by);
                });
            }
        } catch (err) {
            console.error('Failed to sync locked tasks:', err);
        }
    }


    window.updateTaskHighlight = function(taskId, isLocked, locked_by = null) {
        const row = document.querySelector(`.pending-list-row[data-task-id="${taskId}"]`);
        if (!row) return;

        const claimButton = document.getElementById(`claimbutton-${taskId}`);
        const approveButton = document.getElementById(`approve-${taskId}`);
        const rejectButton = document.getElementById(`reject-${taskId}`);
        const assignedCell = row.querySelector('.assigned-to-cell'); 

        if (isLocked) {
            lockedTasks.add(taskId);
            if (assignedCell) assignedCell.textContent = locked_by;
        } else {
            lockedTasks.delete(taskId);
            if (assignedCell) assignedCell.textContent = 'Unassigned';
        }

        const isClaimedByMe = isLocked && locked_by === currentUsername;

        // Visual highlight for *any* lock (The original colors in app3.3.html are light mode specific)
        row.style.border = isLocked ? '2px solid #f87171' : '1px solid #d1d5db';
        row.style.backgroundColor = isLocked ? '#fee2e2' : '#f3f4f6';
        
        // This is a minimal theme adjustment for the text in the row since the element is dynamically created
        row.querySelectorAll('.text-gray-800, .text-gray-500, .text-gray-900').forEach(el => {
             // If the main app is in dark mode, adjust the dynamically added light-colored text
             if (document.body.classList.contains('dark')) {
                  el.classList.remove('text-gray-800', 'text-gray-500', 'text-gray-900');
                  el.classList.add('text-gray-100');
             }
        });


        if (claimButton) {
            claimButton.style.display = isLocked ? 'none' : 'block'; 
            claimButton.disabled = isLocked;
        }
        
        // Enable resolve buttons ONLY if claimed by current user
        if (approveButton && rejectButton) {
            const isReadyToResolve = isClaimedByMe;

            approveButton.disabled = !isReadyToResolve;
            rejectButton.disabled = !isReadyToResolve;

            approveButton.style.display = isReadyToResolve ? 'inline-block' : 'none';
            rejectButton.style.display = isReadyToResolve ? 'inline-block' : 'none';
            
            // Adjust colors based on ready state
            approveButton.classList.toggle('bg-green-600', isReadyToResolve);
            approveButton.classList.toggle('bg-gray-400', !isReadyToResolve);
            rejectButton.classList.toggle('bg-red-600', isReadyToResolve);
            rejectButton.classList.toggle('bg-gray-400', !isReadyToResolve);
        }
    }


    window.resolveTask = async function(taskId, action) {
        const token = localStorage.getItem('authToken');
        const violationSelect = document.getElementById(`violation-${taskId}`);
        let violation_id = null; 

        if (action === 'Rejected') {
            violation_id = violationSelect?.value || null;
            if (!violation_id || violation_id === '0') {
                 alert('Please select a violation before rejecting the task.');
                 return;
            }
        } 
        
        // If Approved, violation_id is explicitly set to null (or 0 in your API's context)
        if (action === 'Approved') {
            violation_id = 0; 
        }

        const res = await fetch(`http://124.107.124.196:3000/api/tasks/${taskId}/resolve`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ action, violation_id })
        });

        const result = await res.json();
        if (result.success) {
            const row = document.querySelector(`.pending-list-row[data-task-id="${taskId}"]`);
            if (row) {
                row.remove();
            }
            alert(`Task ${taskId} ${action.toLowerCase()}!`);
        } else {
            alert(result.message || 'Failed to resolve task');
        }
    }


    window.claimTask = async function(taskId) {
        const token = localStorage.getItem('authToken');
        const res = await fetch(`http://124.107.124.196:3000/api/tasks/${taskId}/claim`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            }
        });

        const result = await res.json();
        if (result.success) {
            updateTaskHighlight(taskId, true, currentUsername);
        } else {
            alert(result.message || 'Failed to claim task');
        }
    }

    // --- MODAL FUNCTIONS (Copied to window object for access from inline HTML) ---
    window.openMediaModal = function(mediaType, url) {
        const modal = document.getElementById('media-modal');
        const contentArea = document.getElementById('modal-content-area');
        contentArea.innerHTML = ''; 

        if (mediaType === 'image') {
            contentArea.innerHTML = `<img src="${url}" alt="Full Image Preview" style="max-width: 100%; max-height: 80vh;">`;
        } else if (mediaType === 'video') {
            contentArea.innerHTML = `
                <iframe 
                    width="800" 
                    height="450" 
                    src="${url}?autoplay=1" 
                    frameborder="0" 
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                    allowfullscreen>
                </iframe>
            `;
        }
        
        modal.style.display = 'flex';
    }

    window.closeMediaModal = function(event) {
        const modal = document.getElementById('media-modal');
        const contentArea = document.getElementById('modal-content-area');
        
        if (event && event.target.id !== 'media-modal') {
            return;
        }

        contentArea.innerHTML = '';
        modal.style.display = 'none';
    }
    
    // --- WEBSOCKET SETUP (Needs to be called on page load/login) ---
    // If the main app handles the WebSocket connection, this should be removed/adapted.
    // For now, assume it runs here and can be simplified.
    window.setupWebSocket = function() {
        if (socket && socket.readyState === WebSocket.OPEN) return;
        const token = localStorage.getItem('authToken');
        // Only set up socket if token exists (i.e., user is logged in)
        if (!token) return; 
        
        socket = new WebSocket(`ws://124.107.124.196:3000/?token=${token}`);

        socket.onmessage = (event) => {
            const msg = JSON.parse(event.data);
            if (msg.type === 'task_locked') {
                updateTaskHighlight(msg.task_id, true, msg.locked_by);
            } else if (msg.type === 'task_unlocked') {
                updateTaskHighlight(msg.task_id, false, 'Unassigned');
            }
        };

        socket.onopen = () => console.log('Content Review WebSocket connected');
        socket.onclose = () => console.warn('Content Review WebSocket disconnected');
    }


    // --- EVENT LISTENERS & INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', () => {
        // Search/Filter Listeners
        document.getElementById('history-search-input')?.addEventListener('input', loadModerationTasks);
        document.getElementById('history-apply-filter-button')?.addEventListener('click', loadModerationTasks);

        // Sortable Headers Listeners (Must be attached after they exist in the DOM)
        document.querySelectorAll('.sortable-header').forEach(header => {
            header.addEventListener('click', () => {
                const key = header.dataset.sortKey;
                if (pendingSortKey === key) {
                  pendingSortDirection = pendingSortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                  pendingSortKey = key;
                  pendingSortDirection = 'asc';
                }
                loadModerationTasks();
            });
        });
        
        // This is the primary function to run when the router loads this page
        setupWebSocket();
        loadContentReviewQueues();
    });
</script>